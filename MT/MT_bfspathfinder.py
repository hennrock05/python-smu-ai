# Midterm
# Author: HennRock05
# Reference: https://www.redblobgames.com/pathfinding/a-star/implementation.html
# 
#   For BFS, DFS s = (10,17), g = (10,2)
#   Precompute all points in order generated by your algorithm,save in data structure. 
#   Program will loop, each time you receive a request from the browser's proxy, return next point as a string x,y of the next point you computed.
#       1. Make Visited list
#       2. Make terrainArray
#       3. Edges (0,0) to (19,19)

# Layout for walls
terrainArr = [{'x': 0, 'y': 8, 'w': 5, 'h': 3},
              {'x': 12, 'y': 9, 'w': 5, 'h': 4},
              {'x': 6, 'y': 4, 'w': 10, 'h': 2},
              {'x': 8, 'y': 13, 'w': 11, 'h': 3},
              {'x': 3, 'y': 6, 'w': 5, 'h': 2}]

import collections


class Queue:
    def __init__(self):
        self.elements = collections.deque()
    
    def empty(self):
        return len(self.elements) == 0
    
    def put(self, x):
        self.elements.append(x)
    
    def get(self):
        return self.elements.popleft()


class SquareGrid:
    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.walls = []
    
    def in_bounds(self, id):
        (x, y) = id
        return 0 <= x < self.width and 0 <= y < self.height
    
    def passable(self, id):
        return id not in self.walls
    
    def neighbors(self, id):
        (x, y) = id
        results = [(x, y + 1),  # N
                   (x + 1, y + 1),  # NE
                   (x + 1, y),  # E
                   (x + 1, y - 1),  # SE
                   (x, y - 1),  # S
                   (x - 1, y - 1),  # SW
                   (x - 1, y),  # W
                   (x - 1, y + 1)]  # NW
        if (x + y) % 2 == 0: results.reverse()  # aesthetics
        results = filter(self.in_bounds, results)
        results = filter(self.passable, results)
        return results
    
    # Function takes the terrainArray as an argument, converts it to
    def convertBlocks(self, dimensions):
        
        # For every block in the terrainArray
        for block in dimensions:
            
            # Min and Max coordinates of rectangles
            x1 = block['x']
            y1 = block['y']
            x2 = x1 + block['w']
            y2 = y1 + block['h']
            
            # Add every point in the rectangle to terrainList
            for x in range(x1, x2 + 1):
                for y in range(y1, y2 + 1):
                    self.walls.append((x, y))


def bfs(graph, start, goal):
    frontier = Queue()
    frontier.put(start)
    visited = {}
    visited[start] = None
    
    ### testing
    visitedlist = []
    
    while not frontier.empty():
        current = frontier.get()
        
        print("Visiting: ", current)
        print("Goal: ", goal)
        if current == goal:
            break
        
        for next_node in graph.neighbors(current):
            if next_node not in visited:
                frontier.put(next_node)
                visitedlist.append(next_node)
                visited[next_node] = current
    
    return visitedlist


# utility functions for dealing with square grids
def from_id_width(id, width):
    return (id % width, id // width)


def draw_tile(graph, id, style, width):
    r = "."
    if 'number' in style and id in style['number']: r = "%d" % style['number'][id]
    if 'point_to' in style and style['point_to'].get(id, None) is not None:
        (x1, y1) = id
        (x2, y2) = style['point_to'][id]
        if x2 == x1 + 1: r = ">"
        if x2 == x1 - 1: r = "<"
        if y2 == y1 + 1: r = "v"
        if y2 == y1 - 1: r = "^"
    if 'start' in style and id == style['start']: r = "A"
    if 'goal' in style and id == style['goal']: r = "Z"
    if 'path' in style and id in style['path']: r = "@"
    if id in graph.walls: r = "#" * width
    return r


def draw_grid(graph, width=2, **style):
    for y in range(graph.height):
        for x in range(graph.width):
            print("%%-%ds" % width % draw_tile(graph, (x, y), style, width), end="")
        print()


def main():
    startPoint = (10, 17)
    goalPoint = (10, 2)
    
    # Create the 19 x 19 grid
    g = SquareGrid(19, 19)
    
    # Convert walls in terrainArray to points on the grid
    g.convertBlocks(terrainArr)
    
    parents = bfs(g, startPoint, goalPoint)
    print(parents)
    draw_grid(g, width=2, point_to=parents, start=startPoint, g=goalPoint)
    

if __name__ == "__main__":
    main()
